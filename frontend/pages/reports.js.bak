import { useEffect, useMemo, useRef, useState } from 'react';
import Layout from '../components/Layout';
import { API_BASE } from '../lib/config';

export async function getServerSideProps({ query }) {
  const qs = new URLSearchParams();
  if (query.channel) qs.set('channel', String(query.channel));
  const url = `${API_BASE}/api/reports${qs.toString() ? ('?' + qs.toString()) : ''}`;
  try {
    const res = await fetch(url);
    if (!res.ok) return { props: { report: null, error: `API ${res.status}` } };
    const { report } = await res.json();
    return { props: { report, error: null } };
  } catch (e) {
    return { props: { report: null, error: e?.message || 'Fetch failed' } };
  }
}

export default function Reports({ report, error }) {
  const [rt, setRt] = useState({ tx_per_sec: 0, alerts_per_min: 0, high_share: 0 });
  const [q, setQ] = useState("");
  const [from, setFrom] = useState(() => report?.timeseries?.daily?.[0]?.date || "");
  const [to, setTo] = useState(() => report?.timeseries?.daily?.slice(-1)?.[0]?.date || "");
  const [fChannel, setFChannel] = useState("");
  const [fSrc, setFSrc] = useState("");
  const [fDst, setFDst] = useState("");
  const [fMinScore, setFMinScore] = useState("");
  const lineRef = useRef(null);
  const lineChartRef = useRef(null);
  const donutRef = useRef(null);
  const barRef = useRef(null);
  const rtRef = useRef(null);
  const rtChartRef = useRef(null);
  const [autoRefresh, setAutoRefresh] = useState(true);
  useEffect(()=>{
    try {
      const p = new URLSearchParams(window.location.search);
      const ch = p.get('channel');
      if (ch) setFChannel(ch);
    } catch {}
  }, []);

  useEffect(() => {
    let charts = [];
    (async () => {
      const { default: Chart } = await import('chart.js/auto');
      if (!report) return;

      const inRange = (d) => (!from || d >= from) && (!to || d <= to);
      const days = report.timeseries.daily.filter(d=>inRange(d.date)).map(d => d.date);
      const dailyCounts = report.timeseries.daily.filter(d=>inRange(d.date)).map(d => d.alerts);
      const predDays = report.timeseries.predictions.map(d => d.date);
      const predCounts = report.timeseries.predictions.map(d => d.alerts);

      // Line chart: actual vs forecast
      const lctx = lineRef.current?.getContext('2d');
      if (lctx) {
        const lineChart = new Chart(lctx, {
          type: 'line',
          data: {
            labels: [...days, ...predDays],
            datasets: [
              { label: 'Alertes', data: [...dailyCounts, ...Array(predCounts.length).fill(null)], borderColor: '#4e79a7', backgroundColor: 'rgba(78,121,167,.2)', tension: .2 },
              { label: 'Prévision', data: [...Array(dailyCounts.length).fill(null), ...predCounts], borderColor: '#f28e2b', borderDash: [6,6], tension: .2 }
            ]
          },
          options: { plugins: { legend: { position: 'bottom' } }, scales: { x: { ticks: { maxRotation: 0 } } } }
        });
        // Enable drill-down on click (only on historical points)
        lineChartRef.current = lineChart;
        const canvas = lineRef.current;
        if (canvas) {
          canvas.onclick = (evt) => {
            const points = lineChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
            if (points && points.length) {
              const idx = points[0].index;
              const label = lineChart.data.labels[idx];
              // Only if point is in historical (non-null) dataset
              const val = lineChart.data.datasets[0].data[idx];
              if (val != null && typeof label === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(label)) {
                setFrom(label);
                setTo(label);
                // Scroll to priorities table
                const pr = document.getElementById('priorities-table');
                if (pr) pr.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }
            }
          };
        }
        charts.push(lineChart);
      }

      // Donut: bands
      const dctx = donutRef.current?.getContext('2d');
      if (dctx) {
        const { HIGH, MEDIUM, LOW } = report.bands;
        charts.push(new Chart(dctx, {
          type: 'doughnut',
          data: {
            labels: ['ÉLEVÉ', 'MOYEN', 'FAIBLE'],
            datasets: [{ data: [HIGH, MEDIUM, LOW], backgroundColor: ['#dc3545','#e2c170','#1f8a5b'] }]
          },
          options: { plugins: { legend: { position: 'bottom' } } }
        }));
      }

      // Bar: channels volume
      const bctx = barRef.current?.getContext('2d');
      if (bctx) {
        const labels = report.channels.map(c => c.channel);
        const counts = report.channels.map(c => c.count);
        const chart = new Chart(bctx, {
          type: 'bar',
          data: { labels, datasets: [{ label: 'Transactions', data: counts, backgroundColor: '#4e79a7' }] },
          options: { plugins: { legend: { display: false } } }
        });
        const canvas = barRef.current;
        if (canvas) {
          canvas.onclick = (evt) => {
            const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
            if (points && points.length) {
              const idx = points[0].index;
              const channel = chart.data.labels[idx];
              if (channel) {
                try { window.location.href = `/reports?channel=${encodeURIComponent(channel)}`; } catch {}
              }
            }
          };
        }
        charts.push(chart);
      }
      // Live line: alerts per minute
      const lrctx = rtRef.current?.getContext('2d');
      if (lrctx) {
        const chart = new Chart(lrctx, {
          type: 'line',
          data: { labels: [], datasets: [{ label: 'Alertes/min (live)', data: [], borderColor: '#7a5195', tension: .25 }] },
          options: { animation: false, plugins: { legend: { display: false } }, scales: { x: { display: false } } }
        });
        rtChartRef.current = chart;
        charts.push(chart);
      }
    })();
    return () => { charts.forEach(c => { try { c.destroy(); } catch {} }); };
  }, [report, from, to]);

  // Real-time SSE
  useEffect(() => {
    const es = new EventSource(`${API_BASE}/api/stream/metrics`);
    es.addEventListener('metrics', (e) => {
      try {
        const data = JSON.parse(e.data);
        setRt(data);
        const chart = rtChartRef.current; if (!chart) return;
        const ds = chart.data.datasets[0];
        chart.data.labels.push('');
        ds.data.push(Number(data.alerts_per_min||0));
        if (ds.data.length > 60) { ds.data.shift(); chart.data.labels.shift(); }
        chart.update('none');
      } catch {}
    });
    es.onerror = () => {};
    return () => { try { es.close(); } catch {} };
  }, []);

  // Auto-refresh report snapshot
  useEffect(() => {
    if (!autoRefresh) return;
    const t = setInterval(async () => {
      try {
        const res = await fetch(`${API_BASE}/api/reports`);
        if (res.ok) {
          const js = await res.json();
          if (js?.report) {
            // naive refresh: reload page data
            location.reload();
          }
        }
      } catch {}
    }, 60000);
    return () => clearInterval(t);
  }, [autoRefresh]);

  const priorities = useMemo(() => {
    const base = (report?.priorityAlerts || []);
    const inRange = (a) => {
      const d = a.created_at ? a.created_at.slice(0,10) : '';
      const ok = (!from || d >= from) && (!to || d <= to);
      return ok;
    };
    const filtered = base.filter(a => inRange(a) && (
      !q ||
      String(a.entity_name||a.entity||'').toLowerCase().includes(q.toLowerCase()) ||
      String(a.details?.hits||'').toLowerCase().includes(q.toLowerCase()) ||
      String(a.suggested_action||'').toLowerCase().includes(q.toLowerCase())
    )).filter(a => (!fChannel || String(a.details?.channel||'') === fChannel))
      .filter(a => (!fSrc || String(a.details?.src_country||'') === fSrc))
      .filter(a => (!fDst || String(a.details?.dst_country||'') === fDst))
      .filter(a => (!fMinScore || Number(a.score||0) >= Number(fMinScore)));
    return filtered.slice(0, 100);
  }, [report, q, from, to, fChannel, fSrc, fDst, fMinScore]);

  const countrySet = useMemo(() => {
    const s = new Set();
    for (const a of (report?.priorityAlerts || [])) {
      if (a?.details?.src_country) s.add(a.details.src_country);
      if (a?.details?.dst_country) s.add(a.details.dst_country);
    }
    return Array.from(s).sort();
  }, [report]);

  async function exportExcel() {
    try {
      const XLSX = (await import('xlsx')).default;
      const wb = XLSX.utils.book_new();
      const ws1 = XLSX.utils.json_to_sheet(priorities.map(p => ({
        id: p.id, score: p.score, amount: p.details?.amount, currency: p.details?.currency,
        entity: p.entity_name || p.entity, hits: (p.details?.hits||[]).join(';'), date: p.created_at
      })));
      XLSX.utils.book_append_sheet(wb, ws1, 'Priorities');
      const ws2 = XLSX.utils.json_to_sheet((report?.timeseries?.daily||[]).map(d=>({date:d.date, alerts:d.alerts})));
      XLSX.utils.book_append_sheet(wb, ws2, 'Daily');
      const ws3 = XLSX.utils.json_to_sheet((report?.channels||[]));
      XLSX.utils.book_append_sheet(wb, ws3, 'Channels');
      const ws4 = XLSX.utils.json_to_sheet((report?.topEntities||[]));
      XLSX.utils.book_append_sheet(wb, ws4, 'TopEntities');
      XLSX.writeFile(wb, `fraudshield-report-${new Date().toISOString().slice(0,10)}.xlsx`);
    } catch (e) { alert('Export Excel échoué: ' + (e?.message||e)); }
  }

  async function exportPDF() {
    try {
      const { jsPDF } = await import('jspdf');
      const html2canvas = (await import('html2canvas')).default;
      const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
      const el = document.getElementById('report-root');
      const canvas = await html2canvas(el, { scale: 2, backgroundColor: '#ffffff' });
      const img = canvas.toDataURL('image/png');
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const imgWidth = pageWidth - 40; const imgHeight = canvas.height * imgWidth / canvas.width;
      doc.addImage(img, 'PNG', 20, 20, imgWidth, Math.min(imgHeight, pageHeight-40));
      doc.save(`fraudshield-report-${new Date().toISOString().slice(0,10)}.pdf`);
    } catch (e) { alert('Export PDF échoué: ' + (e?.message||e)); }
  }

  async function shareTeams() {
    try {
      const { bands } = report || {}; const { HIGH=0, MEDIUM=0, LOW=0 } = bands||{};
      const top = priorities.slice(0,5).map(a => `#${a.id} ${a.entity_name||a.entity} ${a.details?.amount||0} ${a.details?.currency||''} (score ${a.score})`).join("\n");
      const text = `Rapport FraudShield\nBilan: HIGH=${HIGH}, MEDIUM=${MEDIUM}, LOW=${LOW}\nTop priorités:\n${top}`;
      const resp = await fetch(`${API_BASE}/api/share/teams`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text }) });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      alert('Partagé sur Teams (webhook).');
    } catch (e) { alert('Partage Teams échoué: ' + (e?.message||e)); }
  }

  return (
    <Layout>
      <h1 className="page-title">Rapports et Analyses</h1>

      <div className="filters-bar mb-3">
        <div className="row g-2 align-items-center">
          <div className="col-lg-4">
            <div className="input-group">
              <span className="input-group-text" style={{borderRadius:10}}>🔎</span>
              <input className="form-control" placeholder="Rechercher (entité, règles, action)" value={q} onChange={e=>setQ(e.target.value)} />
            </div>
          </div>
          <div className="col-auto">
            <label className="form-label mb-0 me-2">Période</label>
          </div>
          <div className="col-auto">
            <input type="date" className="form-control" value={from || ''} onChange={e=>setFrom(e.target.value)} />
          </div>
          <div className="col-auto">→</div>
          <div className="col-auto">
            <input type="date" className="form-control" value={to || ''} onChange={e=>setTo(e.target.value)} />
          </div>
          <div className="col-auto ms-auto">
            <button className="btn btn-outline-secondary me-2" onClick={exportPDF}>Exporter PDF</button>
            <button className="btn btn-outline-secondary me-2" onClick={exportExcel}>Exporter Excel</button>
            <button className="btn btn-gold" onClick={shareTeams}>Partager Teams</button>
          </div>
        </div>
        <div className="row g-2 mt-2 align-items-center">
          <div className="col-auto">
            <select className="form-select" value={fChannel} onChange={e=>{ setFChannel(e.target.value); try { window.location.href = e.target.value ? `/reports?channel=${encodeURIComponent(e.target.value)}` : '/reports'; } catch {} }}>
              <option value="">Tous canaux</option>
              {(report?.channels||[]).map(c => (<option key={c.channel} value={c.channel}>{c.channel}</option>))}
            </select>
          </div>
          <div className="col-auto">
            <select className="form-select" value={fSrc} onChange={e=>setFSrc(e.target.value)}>
              <option value="">Pays source</option>
              {countrySet.map(c => (<option key={c} value={c}>{c}</option>))}
            </select>
          </div>
          <div className="col-auto">
            <select className="form-select" value={fDst} onChange={e=>setFDst(e.target.value)}>
              <option value="">Pays destination</option>
              {countrySet.map(c => (<option key={c} value={c}>{c}</option>))}
            </select>
          </div>
          <div className="col-auto">
            <select className="form-select" value={fMinScore} onChange={e=>setFMinScore(e.target.value)}>
              <option value="">Score min</option>
              <option value="70">70</option>
              <option value="85">85</option>
              <option value="95">95</option>
            </select>
          </div>
        </div>
      </div>

      {error && <div className="alert alert-danger">Erreur: {error}</div>}
      {!report && !error && <div className="alert alert-info">Chargement des analyses…</div>}

      {report && (
        <>
          <div id="report-root" className="row g-3 mb-3">
            <div className="col-12 col-lg-6">
              <div className="card shadow-sm">
                <div className="card-header">Alertes par jour & prévisions</div>
                <div className="card-body"><canvas ref={lineRef} height="140" /></div>
              </div>
            </div>
            <div className="col-6 col-lg-3">
              <div className="card shadow-sm">
                <div className="card-header">Risque par bande</div>
                <div className="card-body"><canvas ref={donutRef} height="220" /></div>
              </div>
            </div>
            <div className="col-6 col-lg-3">
              <div className="card shadow-sm">
                <div className="card-header">Temps réel (démo)</div>
                <div className="card-body">
                  <div className="mb-1"><strong>Tx/s:</strong> {rt.tx_per_sec}</div>
                  <div className="mb-1"><strong>Alertes/min:</strong> {rt.alerts_per_min}</div>
                  <div className="mb-1"><strong>Part HIGH:</strong> {(rt.high_share*100|0)}%</div>
                  <small className="text-muted">Flux SSE connecté</small>
                  <div className="mt-2"><canvas ref={rtRef} height="80" /></div>
                  <div className="form-check form-switch mt-2">
                    <input className="form-check-input" type="checkbox" id="autoRefresh" checked={autoRefresh} onChange={e=>setAutoRefresh(e.target.checked)} />
                    <label className="form-check-label" htmlFor="autoRefresh">Auto-refresh 60s</label>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div className="row g-3 mb-3">
            <div className="col-12 col-lg-7">
              <div className="card shadow-sm">
                <div className="card-header">Transactions par canal</div>
                <div className="card-body"><canvas ref={barRef} height="150" /></div>
              </div>
            </div>
            <div className="col-12 col-lg-5">
              <div className="card shadow-sm h-100">
                <div className="card-header">Actions suggérées</div>
                <div className="card-body">
                  <ul className="mb-0">
                    {(report.suggestions||[]).map((s,i) => (<li key={i}>{s}</li>))}
                  </ul>
                  <hr />
                  <div className="small text-muted mb-1">Contacts institutions financières (FR)</div>
                  <ul className="mb-0">
                    <li><a href="https://www.economie.gouv.fr/tracfin" target="_blank" rel="noreferrer">TRACFIN (déclarations – goAML)</a></li>
                    <li><a href="https://acpr.banque-france.fr/" target="_blank" rel="noreferrer">ACPR – Banque de France</a></li>
                    <li><a href="https://www.amf-france.org/" target="_blank" rel="noreferrer">AMF – Autorité des marchés financiers</a></li>
                    <li><a href="https://signal.conso.gouv.fr/" target="_blank" rel="noreferrer">SignalConso (signalements consommateurs)</a></li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div className="card shadow-sm mb-3" id="priorities-table">
            <div className="card-header">Tableau des priorités de fraude à traiter</div>
            <div className="table-responsive">
              <table className="table table-sm align-middle mb-0">
                <thead className="table-light">
                  <tr>
                    <th>ID</th><th>Score</th><th>Montant</th><th>Devise</th><th>Entité</th><th>Règles</th><th>Date</th><th>Action suggérée</th>
                  </tr>
                </thead>
                <tbody>
                  {priorities.map(a => (
                    <tr key={a.id}>
                      <td>{a.id}</td>
                      <td>{a.score}</td>
                      <td>{(a.details?.amount||0).toLocaleString()}</td>
                      <td>{a.details?.currency || ''}</td>
                      <td>{a.entity_name || a.entity}</td>
                      <td>{(a.details?.hits||[]).join(', ')}</td>
                      <td>{a.created_at ? new Date(a.created_at).toLocaleString() : ''}</td>
                      <td>{(a.suggested_actions && a.suggested_actions[0]) || a.suggested_action || ''}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

          <div className="card shadow-sm">
            <div className="card-header">Analyse comparative</div>
            <div className="card-body">
              <p className="mb-2">{report.analysisSummary}</p>
              <small className="text-muted">Baseline legacy: SWIFT ≥ 10k. Détectés: {report.baseline.count}</small>
            </div>
          </div>
        </>
      )}
    </Layout>
  );
}
